<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vue直接引入Script资源</title>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>

<body>
  <div id="app"></div>
  <script>
    new Vue({
      el: "#app",
      template: "<div>{{ message }}</div>",
      data() {
        return {
          message: "欢迎来到Vue的世界"
        };
      },
      methods: {
        test(){},
      },
      beforeCreate: function () {
        // 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用
        console.log('beforeCreate', this.message, this.test, this.$el)
      },
      created: function () {
        // 在实例创建完成后被立即调用
        // 在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调
        // 挂载阶段还没开始，$el 属性目前不可见
        console.log('created', this.message, this.test, this.$el)
      },
      beforeMount: function () {
        // 在挂载开始之前被调用：相关的 render 函数首次被调用
        console.log('beforeMount', this.message, this.test, this.$el)
      },
      mounted: function () {
        // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子
        // 如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内

        // mounted 不会承诺所有的子组件也都一起被挂载
        // 如果希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted
        console.log('mounted', this.message, this.test, this.$el)
        this.$nextTick(function () {
          // 此处整个视图已渲染完毕
        })
      },
      beforeUpdate: function () {
        // 数据更新时调用，发生在虚拟 DOM 打补丁之前
        // 这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器
      },
      updated: function () {
        // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子
        // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作
      },
      beforeDestroy: function () {
        // 实例销毁之前调用。在这一步，实例仍然完全可用
      },
      destroyed: function () {
        // Vue 实例销毁后调用
        // 调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁
      }
    });
  </script>
</body>

</html>